# === Installing Packages ======================================================
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("snpStats")
BiocManager::install("SNPRelate")
BiocManager::install("rtracklayer")
BiocManager::install("biomaRt")
install.packages(c("plyr", "GenABEL", "LDheatmap", "doParallel", "ggplot2"))
library("snpStats")
library("SNPRelate")
library("biomaRt")
library("plyr", "GenABEL", "LDheatmap", "doParallel", "ggplot2")
library("rtracklayer")
# === customizing data directory ===============================================
dir.path <- getwd()
# === folder management ========================================================
folder.names <- c("Raw Data", "Filtered Data", "Generated Data",
"GWAS", "Graphics")
for(i in 1:length(folder.names)){
if(file.exists(folder.names[i]) == FALSE){
dir.create(folder.names[i])
}
}
# ******************************************************************************
#path names to variables
p.data.raw <- paste(dir.path, "/", folder.names[1], "/", sep = "")
p.data.filtered <- paste(dir.path, "/", folder.names[2], "/", sep = "")
p.data.generated <- paste(dir.path, "/", folder.names[3], "/", sep = "")
p.gwas <- paste(dir.path, "/", folder.names[4], "/", sep = "")
p.graphics <- paste(dir.path, "/", folder.names[5], "/", sep = "")
# === Input Files ==============================================================
?sprintf #returns character objects that are a formatted combination of input values
gwas.data <- lapply(c(bed="bed", bim="bim", fam="fam", gds="gds"),
function(n) sprintf("%s/GWAStutorial.%s", p.data.raw, n))
clinical.data <- sprintf("%s/GWAStutorial_clinical.csv", p.data.raw)
# === Reading Data in R ========================================================
# Read PLINK files to create a list
# PLINK is a genome association analysis toolkit
# bed files contain individual genotypes
# bin files contain the locations of all SNPs in the data in the genome
# fam files contain information about the individual including family pedigrees
geno.me <- read.plink(gwas.data$bed, gwas.data$bim, gwas.data$fam)
#creating the genotyope object from the geno.me list
genotype <- geno.me$genotype
print(genotype)
head(genotype)
#creating SNP object from the geno.me list
SNP.genome <- geno.me$map
colnames(SNP.genome) <- c("chromosome", "SNP", "gen.dist", "position", "N1",
"N2")
print(head(SNP.genome))
#removing raw data to create space
rm(geno.me)
#reading phenotype data from the clinical file
#apparently using colClasses saves data importing time
#Also, cannot subset genotype without rearranging using colClasses first
phenotype <- read.csv(clinical.data,
colClasses = c("character", "factor", "factor",
rep("numeric", 4)))
rownames(phenotype) <- phenotype$FamID
head(phenotype)
#subsetting genotype to only include individuals with known phenotype
genotype.s <- genotype[phenotype$FamID, ]
#Now we move on to the next script to filter this data
# === Quality Check & Filtering ================================================
## SNP level-filtering
# We want to filter out the common alleles from the SNPs. This
# eliminates/reduces homogeneity from the sample and helps to draw statistically
# significant relationship between the SNP and the trait (phenotype) we are
# interested in. Another thing we use is the call rate. Call rate for a SNP
# is the proportion of individuals in the study for which the corresponding SNP
# information is not missing (i.e. no. of individuals with SNP information/total
# number of individuals in the study). These account for errors in genotyping.
# Creating summary statistics of SNP information
snpsummary.col <- col.summary(genotype.s)
head(col.summary)
# Setting thresholds for the filtering
call <- 0.95 # SNPs with 5% missing data is retained after filtering.
minor.f <- 0.01
# Filtering the SNP data
fil.genotype <- with(snpsummary.col, (!is.na(MAF) & MAF > minor.f)
& Call.rate >= call)
fil.genotype[is.na(fil.genotype)] <- FALSE #Remove NA values
print(ncol(genotype.s)-sum(fil.genotype)) # 203287 SNPs will be removed
#Subset genotype.s for SNPs those meet the MAF and call rate criteria
genotype.s <- genotype.s[,fil.genotype]
# Subset the SNP summary data for SNPs those meet the MAF and call rate criteria
snpsummary.col <- snpsummary[fil.genotype,]
print(genotype.s) #658186 SNPs are remaining
## Sample level filtering
# Want to get rid of individuals with missing data and other criteria such as
# racial, ethnic, or gender ambiguity (GWAS is population dependent)
# We also get rid of contaminated samples (this varies)
# We will use call rate and heterozygosity as thresholds for filtering here.
# Individuals who are missing genotype data for more than 5% of the
# typed SNPs are removed by the 95% call rate. Excess
# heterozygosity across typed SNPs within an individual may be an indication of
# poor sample quality, while deficient heterozygosity can indicate inbreeding or
# other substructure in that person. Thus, samples with an inbreeding
# coefficient |F| = (1 - O/E) > 0.10 are removed, where O and E are respectively
# the observed and expected counts of heterozygous SNPs within an individual.
# Creating summary statistics for the sample
snpsummary.row <- row.summary(genotype.s)
gc()
# Calculating the inbreeding coefficient for the sample
MAF <- snpsummary.col$MAF
callmatrix <- !is.na(genotype.s)
hetExp <- callmatrix %*% (2*MAF*(1-MAF))
hetObs <- with(snpsummary.row, Heterozygosity*(ncol(genotype.s))*Call.rate)
snpsummary.row$hetF <- 1-(hetObs/hetExp)
# Setting thresholds for sample filtering
samp.call <- 0.95       # 95% call rate
het.cutoff <- 0.10      # Inbreeding coefficient cutoff
#Filtering sample based on threshold
fil.sample <- with(snpsummary.row, !is.na(Call.rate) & Call.rate > samp.call &
abs(hetF) <= het.cutoff)
fil.sample[is.na(fil.sample)] <- FALSE   #removing NAs from the sample
print(nrow(genotype.s)-sum(fil.sample))  # 0 subjects removed
# Subset genotype and phenotype data for subjects meeting the heterozygosity and
# call rate criteria
genotype.s <- genotype.s[fil.sample,]
phenotype <- phenotype[rownames(genotype.s),]
head(genotype.s)
# Now we will further filter the sample for relatedness and redundancy.
# We will use the linkage disequilibrium as a threshold to remove redundancy.
# We will use the kinship threshold to remove related individuals from the
# sample pool.
kin.cutoff <- 0.1  # Kinship Cut-Off based on IBD coefficient
ld.cutoff <- 0.2   # LD cut-off. 0.2 seems to be the standard in GWAS.
# Creating the gds files that are required for the SNPRelate functions
# Don't understand why we need to do this, just following the instructions in
# the GWAS tutorials
# Converting from PLINK to GDS
snpgdsBED2GDS(gwas.data$bed, gwas.data$fam, gwas.data$bim, gwas.data$gds)
genofile <- snpgdsOpen(gwas.data$gds, readonly = FALSE)
# Removing automatically added "-1" suffixes
gds.ids <- read.gdsn(index.gdsn(genofile, "sample.id"))
gds.ids <- sub("-1", "", gds.ids)
add.gdsn(genofile, "sample.id", gds.ids, replace = TRUE)
#Prune SNPs for IBD analysis
set.seed(1000)
genosample.ids <- rownames(genotype.s)
snpSUB <- snpgdsLDpruning(genofile, ld.threshold = ld.cutoff,
sample.id = genosample.ids,
snp.id = colnames(genotype.s))
# === GWAS tutorial ============================================================
# authors: Umayeer Milky, Severin Santana
# This code is the same as the one demostrated by Reed et al. (2015). The
# purpose of running this code is to familiarize ourselves with the different
# steps involved in a GWAS analysis in R. Minor modifications to the original
# code has been made as required.
# === Installing Packages ======================================================
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("snpStats")
BiocManager::install("SNPRelate")
BiocManager::install("rtracklayer")
BiocManager::install("biomaRt")
install.packages(c("plyr", "GenABEL", "LDheatmap", "doParallel", "ggplot2"))
library("snpStats")
library("SNPRelate")
library("biomaRt")
library("plyr", "GenABEL", "LDheatmap", "doParallel", "ggplot2")
library("rtracklayer")
# === customizing data directory ===============================================
dir.path <- getwd()
# === folder management ========================================================
folder.names <- c("Raw Data", "Filtered Data", "Generated Data",
"GWAS", "Graphics")
for(i in 1:length(folder.names)){
if(file.exists(folder.names[i]) == FALSE){
dir.create(folder.names[i])
}
}
# ******************************************************************************
#path names to variables
p.data.raw <- paste(dir.path, "/", folder.names[1], "/", sep = "")
p.data.filtered <- paste(dir.path, "/", folder.names[2], "/", sep = "")
p.data.generated <- paste(dir.path, "/", folder.names[3], "/", sep = "")
p.gwas <- paste(dir.path, "/", folder.names[4], "/", sep = "")
p.graphics <- paste(dir.path, "/", folder.names[5], "/", sep = "")
# === Input Files ==============================================================
?sprintf #returns character objects that are a formatted combination of input values
gwas.data <- lapply(c(bed="bed", bim="bim", fam="fam", gds="gds"),
function(n) sprintf("%s/GWAStutorial.%s", p.data.raw, n))
clinical.data <- sprintf("%s/GWAStutorial_clinical.csv", p.data.raw)
#Now we move on to the next script to read the raw data
# === Reading Data in R ========================================================
# Read PLINK files to create a list
# PLINK is a genome association analysis toolkit
# bed files contain individual genotypes
# bin files contain the locations of all SNPs in the data in the genome
# fam files contain information about the individual including family pedigrees
geno.me <- read.plink(gwas.data$bed, gwas.data$bim, gwas.data$fam)
#creating the genotyope object from the geno.me list
genotype <- geno.me$genotype
print(genotype)
head(genotype)
#creating SNP object from the geno.me list
SNP.genome <- geno.me$map
colnames(SNP.genome) <- c("chromosome", "SNP", "gen.dist", "position", "N1",
"N2")
print(head(SNP.genome))
#removing raw data to create space
rm(geno.me)
#reading phenotype data from the clinical file
#apparently using colClasses saves data importing time
#Also, cannot subset genotype without rearranging using colClasses first
phenotype <- read.csv(clinical.data,
colClasses = c("character", "factor", "factor",
rep("numeric", 4)))
rownames(phenotype) <- phenotype$FamID
head(phenotype)
#subsetting genotype to only include individuals with known phenotype
genotype.s <- genotype[phenotype$FamID, ]
#Now we move on to the next script to filter this data
# Creating column summary statistics of SNP information
snpsummary.col <- col.summary(genotype.s)
head(col.summary)
# Setting thresholds for the filtering
call <- 0.95 # SNPs with 5% missing data is retained after filtering.
minor.f <- 0.01
# Filtering the SNP data
fil.genotype <- with(snpsummary.col, (!is.na(MAF) & MAF > minor.f)
& Call.rate >= call)
fil.genotype[is.na(fil.genotype)] <- FALSE #Remove NA values
print(ncol(genotype.s)-sum(fil.genotype)) # 203287 SNPs will be removed
#Subset genotype.s for SNPs those meet the MAF and call rate criteria
genotype.s <- genotype.s[,fil.genotype]
# Subset the SNP summary data for SNPs those meet the MAF and call rate criteria
snpsummary.col <- snpsummary.col[fil.genotype,]
print(genotype.s) #658186 SNPs are remaining
# Creating row summary statistics for the sample
snpsummary.row <- row.summary(genotype.s)
# Calculating the inbreeding coefficient for the sample
MAF <- snpsummary.col$MAF
callmatrix <- !is.na(genotype.s)
hetExp <- callmatrix %*% (2*MAF*(1-MAF))
hetObs <- with(snpsummary.row, Heterozygosity*(ncol(genotype.s))*Call.rate)
snpsummary.row$hetF <- 1-(hetObs/hetExp)
# Setting thresholds for sample filtering
samp.call <- 0.95       # 95% call rate
het.cutoff <- 0.10      # Inbreeding coefficient cutoff
#Filtering sample based on threshold
fil.sample <- with(snpsummary.row, !is.na(Call.rate) & Call.rate > samp.call &
abs(hetF) <= het.cutoff)
fil.sample[is.na(fil.sample)] <- FALSE   #removing NAs from the sample
print(nrow(genotype.s)-sum(fil.sample))  # 0 subjects removed
fil.sample
genotype.s <- genotype.s[fil.sample,]
phenotype <- phenotype[rownames(genotype.s),]
head(genotype.s)
kin.cutoff <- 0.1  # Kinship Cut-Off based on IBD coefficient
ld.cutoff <- 0.2   # LD cut-off. 0.2 seems to be the standard in GWAS.
## Creating the gds files that are required for the SNPRelate functions
## Don't understand why we need to do this, just following the instructions in
## the GWAS tutorials
# Creating gds file as SNPRelate functions require gds files to run
# Converting from PLINK to GDS
snpgdsBED2GDS(gwas.data$bed, gwas.data$fam, gwas.data$bim, gwas.data$gds)
genofile <- snpgdsOpen(gwas.data$gds, readonly = FALSE)
# Removing automatically added "-1" suffixes
gds.ids <- read.gdsn(index.gdsn(genofile, "sample.id"))
gds.ids <- sub("-1", "", gds.ids)
add.gdsn(genofile, "sample.id", gds.ids, replace = TRUE)
#Prune SNPs for IBD analysis
set.seed(1000)
genosample.ids <- rownames(genotype.s)
snpSUB <- snpgdsLDpruning(genofile, ld.threshold = ld.cutoff,
sample.id = genosample.ids,
snp.id = colnames(genotype.s))
snpSUB
snpset.ibd <- unlist(snpSUB, use.names = FALSE)
snpset.ibd
cat(length(snpset.ibd), "will be used in IBD analysis\n") # expect 72890 SNP's
## Find IBD coeeficients using Method of Moments procedure. Include pairwise kinship
ibd <- snpgdsIBDMoM(genofile, kinship = TRUE,
sample.id = genosample.ids,
snp.id = snpset.ibd,
num.thread = 1)
ibdcoeff <- snpgdsIBDSelection(ibd) # Pairwise sample comparison
head(ibdcoeff)
# check if there are any candidates for relatedness
ibdcoeff <- ibdcoeff [ibdcoeff$kinship >= kin.cutoff, ]
##iteratively remove samples with high kindship starting with the sample with
## the most pairings
related.samples <- NULL
while (nrow(ibdcoeff) > 0 ) {
## count the number of occurrences of each and take the top one
sample.counts <- arrange(count(c(ibdcoeff$ID1, ibdcoeff$ID2)), -freq)
rm.sample <- sample.counts[1, "x"]
cat("Removing sample", as.character(rm.sample), "too closely related to",
sample.counts[1, "freq"], "other samples. \n")
## remove from ibdcoeff and add to list
ibdcoeff <- ibdcoeff[ibdcoeff$ID1 !=rm.sample & ibdcoeff$ID2 != rm.sample,]
related.samples <- c(as.character(rm.sample), related.samples)
}
## filter genotype and clinical to include only unrelated samples
genotype.s <- genotype.s[!(rownames(genotype.s) %in% related.samples),]
phenotype <- phenotype[!(phenotype$FamID %in% related.samples),]
genosample.ids <- rownames(genotype.s)
cat(length(related.samples), "similar samples removed due to
cat(length(related.samples), "similar samples removed due to
correlation coefficient >=", kin.cutoff, "\n")
cat(length(related.samples), "similar samples removed due to correlation coefficient >=", kin.cutoff, "\n")
cat(length(related.samples), "similar samples removed due to
correlation coefficient >=", kin.cutoff, "\n")
print(genotype.s) # except all 1401 subject remain
# setting threshold for HWE test p < 1x10^10-6
HWE.thres <- 10^-6
CADcontrols <- phenotype[phenotype$CAD==0, 'FamID' ]
snpsum.col.cont <- col.summary(genotype.s[CADcontrols,])
HWE.use <- with(snpsum.col.cont, !is.na(z.HWE) & ( abs(z.HWE) < abs( qnorm(HWE.thres/2))))
HWE.use
HWE.use[is.na(HWE.use)] <- FALSE          # Remove NA's as well
HWE.use
HWE.use[is.na(HWE.use)] <- FALSE          # Remove NA's as well
cat(ncol(genotype.s)-sum(HWE.use)),"SNPs will be removed due to high HWE.\n"
cat(ncol(genotype.s)-sum(HWE.use),"SNPs will be removed due to high HWE.\n")
## subset genotype and SNP summary data for SNPs that pass HWE criteria
genotype.s <- genotype.s[,HWE.use]
print(genotype.s)
ld.cutoff <- 0.2
set.seed(1000)
genosample.ids <- rownames(genotype.s)
snpSUB <- snpgdsLDpruning(genofile, ld.threshold = ld.cutoff,
sample.id = genosample.ids, # only analyze filtered samples
snp.id = colnames(genotype.s)) # only analyze filtered samples
snpset.pca <- unlist(snpSUB, use.names = FALSE)
cat(length(snpset.pca), "\n") #
pca <- snpgdsPCA(genofile, sample.id = genosample.ids,
snp.id = snpset.pca, num.thread = 1)
## pcs will be a N:10 matrix. Each column is a principal component.
pcs <- data.frame(FAMID = pca$sample.id, pca$eigenvect[,1:10],
stringsAsFactors = FALSE)
colnames(pcs)[2:11] <- paste("pc", 1:10, sep ="")
print(head(pcs))
pcs
thougeno <- read.pedfile(onethou.fn$ped, snps = onethou.fn$info, which = 1)
chr16_1000g_CEU.pedchr16_1000g_CEU.ped
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(chr16_1000g_CEU.ped, snps = onethou.fn$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile('chr16_1000g_CEU.ped', snps = onethou.fn$info, which = 1)
?read.pedfile()
?read.pedfile()
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(p.data.raw$chr16_1000g_CEU.ped', snps = onethou.fn$info, which = 1)
thougeno
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(p.data.raw$chr16_1000g_CEU.ped', snps = onethou.fn$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(p.data.raw$chr16_1000g_CEU.ped, snps = onethou.fn$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(paste(p.data.raw, "chr16_1000g_CEU.ped", sep = ""), snps = onethou.fn$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(onthou.fn(p.data.raw, "chr16_1000g_CEU.ped", sep = ""), snps = onethou.fn$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(onthou.fn$ped, snps = onethou.fn$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(paste(p.data.raw, "chr16_1000g_CEU.ped", sep = ""), snps = $info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(paste(p.data.raw, "chr16_1000g_CEU.ped", sep = ""), which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(chr16_1000g_CEU.ped$ped, snps = $info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(chr16_1000g_CEU.ped$ped, snps = chr16_1000g_CEU.ped$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(chr16_1000g_CEU.ped$ped, snps = chr16_1000g_CEU.ped$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(chr16_1000g_CEU.ped, snps = chr16_1000g_CEU.ped$info, which = 1)
# read in 1000g data for given chromosome 16
thougeno <- read.pedfile(onthou.fn$ped, snps = onthou.fn$info, which = 1)
gwas.data <- lapply(c(bed="bed", bim="bim", fam="fam", gds="gds"),
function(n) sprintf("%s/GWAStutorial.%s",
p.data.raw, n))
clinical.data <- sprintf("%s/GWAStutorial_clinical.csv", p.data.raw)
onethou.fn <- lapply(c(info='info',ped='ped'),
function(n) sprintf("%s/chr16_1000g_CEU.%s",
dp.data.raw, n))
protein.coding.coords.fname <- sprintf("%s/ProCodgene_coords.csv", p.data.raw)
gwas.data <- lapply(c(bed="bed", bim="bim", fam="fam", gds="gds"),
function(n) sprintf("%s/GWAStutorial.%s",
p.data.raw, n))
clinical.data <- sprintf("%s/GWAStutorial_clinical.csv", p.data.raw)
onethou.fn <- lapply(c(info='info',ped='ped'),
function(n) sprintf("%s/chr16_1000g_CEU.%s",
p.data.raw, n))
protein.coding.coords.fname <- sprintf("%s/ProCodgene_coords.csv", p.data.raw)
thougeno <- read.pedfile(onethou.fn$ped, snps = onethou.fn$info, which = 1)
# obtain genotype data for given chromosome
geno.matrix <- thougeno$genotypes
geno.matrix
support <- thougeno$map
colnames(support) <- c("SNP", "position", "N1", "N2")
head(support)
## imputation of non-typed 1000g SNPs
## subset for SNPs on given chromosome
pres.SNPS <- colnames(genotype.s)
pres.dat.chr <- genoBim[genoBim$SNP]
# === Reading Data in R ========================================================
# Read PLINK files to create a list
# PLINK is a genome association analysis toolkit
# bed files contain individual genotypes
# bin files contain the locations of all SNPs in the data in the genome
# fam files contain information about the individual including family pedigrees
geno.me <- read.plink(gwas.data$bed, gwas.data$bim, gwas.data$fam)
# creating the genotyope object from the geno.me list
genotype <- geno.me$genotype
print(genotype)
head(genotype)
# obtain the SNP information from geno list
geno.bim <- geno$map
colnames(geno.bim) <- c("chr", "SNP", "gen.dist", "position", "A1", "A2")
print(head(geno.bim))
#creating SNP object from the geno.me list
SNP.genome <- geno.me$map
colnames(SNP.genome) <- c("chromosome", "SNP", "gen.dist", "position", "N1",
"N2")
print(head(SNP.genome))
#removing raw data to create space
rm(geno.me)
#reading phenotype data from the clinical file
#apparently using colClasses saves data importing time
#Also, cannot subset genotype without rearranging using colClasses first
phenotype <- read.csv(clinical.data,
colClasses = c("character", "factor", "factor",
rep("numeric", 4)))
rownames(phenotype) <- phenotype$FamID
head(phenotype)
#subsetting genotype to only include individuals with known phenotype
genotype.s <- genotype[phenotype$FamID, ]
# write genotype, geno.bim, phenotype for future use
save(genotype, geno.bim, phenotype, file = working.data.fname(1))
# === Reading Data in R ========================================================
# Read PLINK files to create a list
# PLINK is a genome association analysis toolkit
# bed files contain individual genotypes
# bin files contain the locations of all SNPs in the data in the genome
# fam files contain information about the individual including family pedigrees
geno.me <- read.plink(gwas.data$bed, gwas.data$bim, gwas.data$fam)
# creating the genotyope object from the geno.me list
genotype <- geno.me$genotype
print(genotype)
head(genotype)
# obtain the SNP information from geno list
geno.bim <- geno.me$map
colnames(geno.bim) <- c("chr", "SNP", "gen.dist", "position", "A1", "A2")
print(head(geno.bim))
#creating SNP object from the geno.me list
SNP.genome <- geno.me$map
colnames(SNP.genome) <- c("chromosome", "SNP", "gen.dist", "position", "N1",
"N2")
print(head(SNP.genome))
#removing raw data to create space
rm(geno.me)
#reading phenotype data from the clinical file
#apparently using colClasses saves data importing time
#Also, cannot subset genotype without rearranging using colClasses first
phenotype <- read.csv(clinical.data,
colClasses = c("character", "factor", "factor",
rep("numeric", 4)))
rownames(phenotype) <- phenotype$FamID
head(phenotype)
#subsetting genotype to only include individuals with known phenotype
genotype.s <- genotype[phenotype$FamID, ]
# write genotype, geno.bim, phenotype for future use
save(genotype, geno.bim, phenotype, file = working.data.fname(1))
# on to script 3.Data.filtering
pres.SNPS <- colnames(genotype.s)
pres.dat.chr <- geno.bim[geno.bim$SNP %in% pres.SNPS & geno.bim$chr==16,]
target.SNPS <- pres.dat.chr$SNP
## subset 1000g data for our SNPs
## "missing" and "present are snpMatrix objects needed for imputation rules
is.present <- colnames(geno.matrix) %in% target.SNPS
missing <- geno.matrix[,is.present]
print(missing)
missing <- geno.matrix[,!is.present]
print(missing)
present <- geno.matrix[, is.present]
print(present)
pos.present <- support$position[is.present]
pos.missing <- support$position[!is.present]
# calculate and store the imputation rules using snp.imputation()
rules <- snp.imputation(present, missing, pos.present, pos.missing)
# remove failed imputations
rules <- rules[can.impute(rules)]
rules <- rules[can.impute(rules)]
cat("Imputation rules for", length(rules), "SNPs were estimated\n")
r2threshold <- 0.7
minor <- 0.01
# filter on imputation certainty and MAF
rules <- rules[imputation.r2(rules) >= r2threshold]
cat(length(rules)), "imputation rules remain after uncertain imputations were removed\n"
cat(length(rules), "imputation rules remain after uncertain imputations were removed\n")
rules <- rules[imputation.maf(rules) >= minor]
cat(length(rules), "imputation rules remain after MAF filtering\n"
cat(length(rules), "imputation rules remain after MAF filtering\n")
rules <- rules[imputation.maf(rules) >= minor]
cat(length(rules), "imputation rules remain after MAF filtering\n")
rules
cat(length(rules), "imputation rules remain after MAF filtering\n")
target <- genotype.s[, target.SNPS]
imputed <- impute.snps(rules, target, as.numeric = FALSE)
print(imputed)
# merge clinical data and principal components to create phenotype table
pheno.sub <- merge(phenotype,pcs)
pheno.sub
?merge
# merge clinical data and principal components to create phenotype table
pheno.sub <- merge(phenotype,pcs, no.dups = TRUE)
pheno.sub
